[["spatial-analysis.html", "Chapter 7 Spatial Analysis 7.1 SpATS", " Chapter 7 Spatial Analysis body { text-align: justify} Agricultural fields are often very heterogenous, and one when we intend to determine the genetic value of a given set of genotype, it is often useful to use methods that account for this variability (Singh et al. 2003). Several methodological and statistical approaches can be used to address this use. In this chaper, we will cover the use of SpATS, and (hopefully soon) the use of other packages. 7.1 SpATS SpATS (Spatial Analysis of field Trials with Splines) is an approach for spatial analysis developed by Rodríguez-Álvarez et al. (2018). In general, it uses the row-column two-dimensional smooth surfaces to model random spatial variation. The proper explanation of the statistics behind can be found here and here. As usual, before using the package, it must be installed. install.packages(&quot;SpATS&quot;) And then called: library (SpATS) We will use the same tomato data that we have been using in the previous chapter. mydata &lt;- read.csv(&quot;tomatoMLT2020.csv&quot;) So, to properly perform the analysis, we can only use data from one location, in order to grasp the spatial heterogeneity of that specific farm. So, we first subset the data only from Sestola, one of our four locations. data.Sestola &lt;- subset(mydata, location == &quot;Sestola&quot;) With this object, we can now run the function SpATS, as showed and explained here: spats.Sestola = SpATS(data= data.Sestola, # My subset from Sestola response= &quot;yield&quot;, # The name of my variable genotype = &quot;variety&quot;, # The name of my genotupe columns genotype.as.random = F, # This is a long story. # But this argument determines if # genotypes set as random or as fixed in my model. # In the first case, I will obtain BLUPs # values, and in the second, BLUEs values. spatial = ~ SAP(row, col)) # This arguments designs the row-column distribution of the field We created an object called spats.Sestola and we can plot it inmediately. In this plot we can see the raw data, the data fitted to the spatial model, the residuals of the model, the smoothed spatial trend and the BLUES values. plot(spats.Sestola) We are intereseted in the BLUES (or the BLUPS), which is an estimate (or a prediction) of the breeding genetic value for each genotype. In the plot, they are given as a deviation from the mean. If we add the overall mean value to that number, we would have what we call an adjusted mean. In SpATS, this can be done through predict(). adj.means = predict(spats.Sestola, which = &#39;variety&#39;) adj.means ## variety row col predicted.values standard.errors ## 88 Var. A Excluded Excluded 867.3824 248.6114 ## 91 Var. B Excluded Excluded 788.9379 212.0287 ## 87 Var. C Excluded Excluded 893.9095 218.2514 ## 99 Var. D Excluded Excluded 1232.2897 214.7301 ## 85 Var. E Excluded Excluded 1096.1994 303.3213 ## 86 Var. F Excluded Excluded 919.5207 210.7567 ## 98 Var. G Excluded Excluded 869.4760 208.5983 ## 95 Var. H Excluded Excluded 850.8442 201.3184 ## 97 Var. I Excluded Excluded 913.4908 204.0684 ## 94 Var. J Excluded Excluded 1004.0451 199.2065 ## 93 Var. K Excluded Excluded 968.4633 208.0695 ## 96 Var. L Excluded Excluded 1176.2738 254.1530 ## 92 Var. M Excluded Excluded 1206.4843 229.8201 ## 90 Var. N Excluded Excluded 1106.9766 226.3251 And now, I could plot this adjusted means with ggplot. library(ggplot2) ggplot(adj.means, aes(x= variety, y = predicted.values))+ geom_bar(stat= &quot;identity&quot;, fill = &quot;tomato&quot;)+ geom_errorbar( aes(ymax = predicted.values+ standard.errors, ymin = predicted.values- standard.errors)) To better understand the kind of transformation that we did to the data, we can take a look at this plot, which represents the raw yield numbers for each plot in the field. ggplot(data.Sestola, aes(x=row, y = col, label= variety, fill = yield))+ geom_tile()+ geom_text()+ scale_fill_gradientn(colors=c(&quot;blue&quot;, &quot;lightblue&quot;, &quot;green3&quot;, &quot;yellow&quot;, &quot;red&quot;)) We can see some examples, for instance: Var. D was the best variety. It had an outstanding performance in Column 6 Row 1 and then, an average performance in Row 3 Column 4. The combination of both performances allowed this variety to have the highest BLUE value. Var. H had the lowest adjusted mean. Both repetitions were more or less in the center of the plot, but both had bad performances. At the end, we end up with a very low BLUE value. Moreover, the SpATS object we have just created is full of different objects, that could be further explored, for example\": spats.Sestola$call # The original call spats.Sestola$model # The parameters of the model spats.Sestola$deviance # The deviance indicate how appropiate is the fitting of the model. spats.Sestola$coeff # This is the coefficient for every factor, including genotype and field position. We then would have to do the same for every environment. We could do it manually, writing the code above for every environment. It is possible, but lenghty. We will here propose the code to do through a loop function. Looping in R (and in general) is extremely useful, and we will use this example to show the basics on how looping is done. First, we create a list of the elements that will be used in my loop. In our case, the list will contain the 4 location name. Alternatively, and most commonly, the lists are simply a sequence of numbers. mylocs = unique(mydata$loc) # The unique() function takes the unique values from a vector mylocs ## [1] &quot;Molise&quot; &quot;Rotonda&quot; &quot;Castronuovo&quot; &quot;Sestola&quot; Now, we will draw the loop. The main function is for() followed by curly braces {}. The for() defines a how to go over the loop. We will write for (i in mylocs) meaning that i is a variable that will take the value of each one of the elements in my list (the location names). And then, everything inside the curly braces is what will be done with i being a given value within the list for (i in mylocs){ # i is a variable that will take the value of every element in mylocs myenv = i # Define &quot;myenv&quot; as whatever we have in i mysubset= subset(mydata, location == i) # Make a subset with environment i myspats = SpATS(response = &quot;yield&quot;, # This is the SpATS function we saw before genotype = &quot;variety&quot;, genotype.as.random = F, data= mysubset, # The data is coming from the specific subset done within the loop spatial = ~ SAP(row, col)) adjusted.means &lt;- predict(myspats, # With &quot;myspats&quot;, we estimate the adjusted means which = &quot;variety&quot;) adjusted.means$location &lt;- myenv # To our &quot;adjusted.means&quot; data frame, we add a column with the name of environment assign(value = adjusted.means[,c(6,1,4,5)], # I want to save the adjusted means object (while also rearranging column order) x= paste0(&quot;means.&quot;,myenv)) # with a new name define as &quot;means.myenv&quot;, where myenv is the actual name of the environment } The possibilities of looping are vast. We could, for example, create a new loop, within our main loop, for also obtaining the adjusted means for other variables. We will not do it for now. Now, we have four different adjusted means object, one for each environment. We could bind the with the rbind() function, which stands for rowbind. all.means &lt;- rbind(means.Castronuovo, means.Molise, means.Rotonda, means.Sestola) #We can additionally change some column names to make things more clean names(all.means)[3] &lt;- &quot;yield_adj_mean&quot; names(all.means)[4] &lt;- &quot;yield_sd&quot; And we plot it: ggplot(data= all.means, # Our data frame aes(x=variety, # Variety is the x axis y=yield_adj_mean))+ # Yield Adjusted Means are the y axis geom_bar(stat=&#39;identity&#39;, # The bars are plotted according to the identity actual values in the cells fill= &quot;tomato&quot;)+ # and filled with &quot;tomato&quot; color facet_wrap(location~.)+ # Make a facet per each location labs(x= &quot;Genotype&quot;,y= &quot;Yield&quot;) + # Axis labels geom_errorbar( #Error bars aes(ymin=yield_adj_mean - yield_sd, ymax=yield_adj_mean + yield_sd), width=0.2)+ theme(axis.text.x = element_text(angle =90)) Moreover, given that ggplot can handle plotting data from two different data sources, we could do the same plot, but including also the raw data, and check for the main differences between both. ggplot(data= all.means, # Our data frame aes(x=variety, # Variety is the x axis y=yield_adj_mean))+ # Yield Adjusted Means are the y axis geom_bar(stat=&#39;identity&#39;, # The bars are plotted according to the identity actual values in the cells fill= &quot;tomato&quot;)+ # and filled with &quot;tomato&quot; color facet_wrap(location~.)+ # Make a facet per each location labs(x= &quot;Genotype&quot;,y= &quot;Yield&quot;) + # Axis labels geom_errorbar( #Error bars aes(ymin=yield_adj_mean - yield_sd, ymax=yield_adj_mean + yield_sd), width=0.2)+ theme(axis.text.x = element_text(angle =90))+ geom_point(data= mydata, aes(x= variety,y=yield), col= &quot;darkgreen&quot;)+ # A point for every raw yield observation geom_point(data= mydata, aes(x= variety,y=yield), stat = &quot;summary&quot;, # And a cross for the mean of the rar observations. fun = &quot;mean&quot;, col= &quot;darkgreen&quot;, shape= 4) References "]]
