[["spatial-analysis.html", "Chapter 7 Spatial Analysis 7.1 SpATS", " Chapter 7 Spatial Analysis 7.1 SpATS The package SpATS is here explained. The proper explanation of the statistics behind can be found here and here. Before using the package, it must be installed. install.packages(&quot;SpATS&quot;) And then called: library (SpATS) We will use the same tomato data that we have been using: So, to properly perform the analysis, we can only use data from one location, in order to grasp the spatial heterogeneity of that specific farm. So, we first subset the data from Sestola data.Sestola &lt;- subset(mydata, location == &quot;Sestola&quot;) spats.Sestola = SpATS(data= data.Sestola, #My subset from Sestole response= &quot;yield&quot;, #The name of my variable genotype = &quot;variety&quot;, #The name of my genotupe columns genotype.as.random = F, #This is a long story. Genotypes set as random or as fixed. # define my model. In the first case, I will obtain BLUPs # values, and in the seconed, BLUEs values. spatial = ~ SAP(row, col)) #This arguments designs the row-column distribution of the field plot(spats.Sestola) We are intereseted in the BLUES (or the BLUPS), which is an estimate (or a prediction) of the breeding genetic value for each genotype. In the plot, it is given as a deviation from the mean. If we add the overall mean value to that number, we would have what we call an adjusted mean. In SpATS, this can be done through predict(). adj.means = predict(spats.Sestola, which = &#39;variety&#39;) adj.means ## variety row col predicted.values standard.errors ## 88 Var. A Excluded Excluded 867.3824 248.6114 ## 91 Var. B Excluded Excluded 788.9379 212.0287 ## 87 Var. C Excluded Excluded 893.9095 218.2514 ## 99 Var. D Excluded Excluded 1232.2897 214.7301 ## 85 Var. E Excluded Excluded 1096.1994 303.3213 ## 86 Var. F Excluded Excluded 919.5207 210.7567 ## 98 Var. G Excluded Excluded 869.4760 208.5983 ## 95 Var. H Excluded Excluded 850.8442 201.3184 ## 97 Var. I Excluded Excluded 913.4908 204.0684 ## 94 Var. J Excluded Excluded 1004.0451 199.2065 ## 93 Var. K Excluded Excluded 968.4633 208.0695 ## 96 Var. L Excluded Excluded 1176.2738 254.1530 ## 92 Var. M Excluded Excluded 1206.4843 229.8201 ## 90 Var. N Excluded Excluded 1106.9766 226.3251 And I could plot them. library(ggplot2) ggplot(adj.means, aes(x= variety, y = predicted.values))+ geom_bar(stat= &quot;identity&quot;, fill = &quot;tomato&quot;)+ geom_errorbar( aes(ymax = predicted.values+ standard.errors, ymin = predicted.values- standard.errors)) To better understand the kind of transformation that we did to the data, we can take a look at this plot, which represents the raw yield numbers for each plot in the field. ggplot(data.Sestola, aes(x=row, y = col, label= variety, fill = yield))+ geom_tile()+ geom_text()+ scale_fill_gradientn(colors=c(&quot;blue&quot;, &quot;lightblue&quot;, &quot;green3&quot;, &quot;yellow&quot;, &quot;red&quot;)) We can see some examples, for instance: Var. D was the best variety. It had an outstanding performance in Column 6 Row 1 and then, an average performance in Row 3 Column 4. The combination of both performances allowed this variety to have the highest BLUEs value. Var. H had the lowest adjusted mean. Both repetitions were more or less in the center of the plot, but both had bad performances. Moreover, the SpATS object we have just created is full of different objects, for example spats.Sestola$call # The original call spats.Sestola$model # The parameters of the model spats.Sestola$deviance # The deviance indicate how appropiate is the fitting of the model. spats.Sestola$coeff # This is the coefficient for every factor, including genotype and field position. We then would have to do the same for every environment. We could do it manually, writing the code above for every environment. It is possible, but lenghty. We will here propose the code to do it into a loop function. Looping in R (and in general) is extremely useful, and we will use this example to show the basics on how looping is done. First, we create a list of the elements that will be used in my loop. In our case, the list will contain the 4 location name. Alternatively, and most commonly, the lists are simply a sequence of numbers. mylocs = unique(mydata$loc) # The unique() function takes the unique values from a vector mylocs ## [1] &quot;Molise&quot; &quot;Rotonda&quot; &quot;Castronuovo&quot; &quot;Sestola&quot; Now, we will draw the loop. The main function is for() followed by curly braces {}. The for() defines a how to go over the loop; we will write for (i in mylocs) meaning that i is a variable that will take the value of each one of the elements in my list (the location names). And then, everything inside the curly braces is what will be done with i being a given value within the list for (i in mylocs){ # i is a variable that will take the value of every element in mylocs myenv = i # Define &quot;myenv&quot; as whatever we have in i mysubset= subset(mydata, location == i) # Make a subset with environment i myspats = SpATS(response = &quot;yield&quot;, # This is the SpATS function we saw before genotype = &quot;variety&quot;, genotype.as.random = F, data= mysubset, # The data is coming from the specific subset done within the loop spatial = ~ SAP(row, col)) adjusted.means &lt;- predict(myspats, # With &quot;myspats&quot;, we estimate the adjusted means which = &quot;variety&quot;) adjusted.means$location &lt;- myenv # To our &quot;adjusted.means&quot; data frame, we add a column with the name of environment assign(value = adjusted.means[,c(6,1,4,5)], # I want to save the adjusted means object (rearrangin column order) x= paste0(&quot;means.&quot;,myenv)) # with a new name define as &quot;means.myenv&quot;, where myenv is the actual name of the environment } The possibilities of looping are vast. We could, for example, create a new loop, within our main loop, for also obtaining the adjusted means for other variables. We will not do it for now. Now, we have four different adjusted means object, one for each environment. We could bind the with the rbind() function, which stands for rowbind. all.means &lt;- rbind(means.Castronuovo, means.Molise, means.Rotonda, means.Sestola) #We can additionally change some column names to make things more clean names(all.means)[3] &lt;- &quot;yield_adj_mean&quot; names(all.means)[4] &lt;- &quot;yield_sd&quot; And we plot it: ggplot(data= all.means, # Our data frame aes(x=variety, # Variety is the x axis y=yield_adj_mean))+ # Yield Adjusted Means are the y axis geom_bar(stat=&#39;identity&#39;, # The bars are plotted according to the identity actual values in the cells fill= &quot;tomato&quot;)+ # and filled with &quot;tomato&quot; color facet_wrap(location~.)+ # Make a facet per each location labs(x= &quot;Genotype&quot;,y= &quot;Yield&quot;) + # Axis labels geom_errorbar( #Error bars aes(ymin=yield_adj_mean - yield_sd, ymax=yield_adj_mean + yield_sd), width=0.2)+ theme(axis.text.x = element_text(angle =90)) Moreover, given that ggplot can handle plotting data from two different data sources, we could do the same plot, but including also the raw data, and check for the main differences between both. ggplot(data= all.means, # Our data frame aes(x=variety, # Variety is the x axis y=yield_adj_mean))+ # Yield Adjusted Means are the y axis geom_bar(stat=&#39;identity&#39;, # The bars are plotted according to the identity actual values in the cells fill= &quot;tomato&quot;)+ # and filled with &quot;tomato&quot; color facet_wrap(location~.)+ # Make a facet per each location labs(x= &quot;Genotype&quot;,y= &quot;Yield&quot;) + # Axis labels geom_errorbar( #Error bars aes(ymin=yield_adj_mean - yield_sd, ymax=yield_adj_mean + yield_sd), width=0.2)+ theme(axis.text.x = element_text(angle =90))+ geom_point(data= mydata, aes(x= variety,y=yield), col= &quot;darkgreen&quot;)+ # A point for every raw yield observation geom_point(data= mydata, aes(x= variety,y=yield), stat = &quot;summary&quot;, # And a cross for the mean of the rar observations. fun = &quot;mean&quot;, col= &quot;darkgreen&quot;, shape= 4) "]]
